---
layout: post
title: CSRF
categories: [etc]
---

#CSRF 
 사이트간 요청위조(Cross-site request forgery, CSRF)의 약자로, 서버를 공격하기 위한 공격 의도를 가지고 있다.   
서버에서 인증을 받고있는 사용자의 상태를 이용해 타 기관의 attacker가 서버로 공격한다.
서버에 공격자의 의도를 보내서 실행할 수 있다. 인증받은 사용자의 상태를 이용하기 때문에 attacker가 공격을 할 수 있기 위해서는 
첫째, 사용자는 해당 서버로 인증을 받고 있는 상태여야한다. 둘째, attacker의 피싱에 사용자가 당해야한다. 
예를 들어보자.   


일반 유저는 A서버에 로그인해서 게시판에 글을 쓰고, 수정할 수 있는 인증상태를 가지고 있다. 
일반 유저는 A서버에 로그인한 상태에서 메일 서비스에 들어가 피싱 메일을 받았다.
피싱 메일을 열어보는 순간, 피싱메일에 숨겨진 코드는 A서버로 게시판의 글을 쓸 수 있는 권리를 취득해서,
A서버로 피싱글을 작성한다. A서버는 피싱메일로부터 보낸 코드가 인증을 준 일반 유저가 작성한 내용이라고 가정을 하고 
attacker의 의도를 실행한다.

CSRF 공격을 피하기 위해서 간단하게 두 가지 방법이 있다.

### 1. 서버에서 요청을 보낸 클라이언트의 referer를 체크하는 방법.
--- 
 서버는 클라이언트에서 보낸 요청이 허용된 whitelist에서 보낸 올바른 요청인지를 확인하는 방법으로 referer를 체크해서 일차적으로 걸러줄 수 있다.
하지만, referer검증만으로는 부족하다.

### 2. 서버에서 요청을 할 때 CSRF토큰을 발행한다.
---
CSRF토큰은 이 유저에게 권한을 주는 토큰이 아니라, 서버가 클라이언트에게 부여하는 '너는 나로부터 인증된 클라이언트야'를 인증할 수 있는 토큰이다. 서버는 특정한 기간마다 특정한 알고리즘을 가진 랜덤한 값을 생성해서 
클라이언트에게 토큰을 보내주고, 그 값을 보유하고 있다. 클라이언트는 다음번 요청에서 해당 토큰을 서버에 함께 보내줌으로써 서버가 본인이 가진 토큰과 클라이언트가 보내준 토큰이 동일한지 체크할 수 있도록 한다. 서버는 토큰의 동일한지를 비교해서 
나에게 이전에 올바른 요청을 보낸, 인증된 클라이언트임을 확신한다.
s

